
;;; -----------------------------
;;; CONSTRAINT DEFINITIONS
;;; -----------------------------

;;; Superclass for all constraints
(define-class general-joint-solid-model
  :inherit-from (frame-data-model)
  :properties (
               max-element-size (deafult 0.04)
			   min-element-size (deafult 0.01)
               scale-factor (default 1.2)
               
               point-ref (default nil)
               direction (default nil)
               (z-vector-ref :class 'vector-data-model
                   direction ^^direction
                   )
               (x-vector-ref :class 'vector-data-model
                   direction (arbitrary-normal-to-vector ^^direction)
                   )
               
               constraint-type (default nil)
               
               ;from-link (nth (position (nth 0 ^link-incidence) ^^link-list) ^^link-ref-list)
               ;to-link (nth (position (nth 1 ^link-incidence) ^^link-list) ^^link-ref-list)
               
               link-incidence (default nil)

               link-ref-incident-on-constraint nil
               
               constraint-variable (default (list ))
               )
  )

(define-method get-constraint-type general-joint-solid-model ()
	!constraint-type
	)
  
(define-class load-model
	:inherit-from (union-object)
	:properties (
				 load-type 		(default nil)
				 magnitude 		(default nil)
				 load-direction	(default nil)
				 loadID			(default nil)
				 
				 
				 )
)
 
;;; Class for holding male and female instantiations as subobjects
(define-class master-joint-model
  :inherit-from (general-joint-solid-model)
  :properties (
               id (default nil)
			   
			   (max-width :class 'editable-data-property-class
					label "Max width"
					;;Have to check if the max dimensions are not nil to avoid error. Workaround for the open constraint type.
				formula (let (
								   (fem-max (first (the local-max-dimension (:from ^female-element-solid-model))))
								   (male-max (first (the local-max-dimension (:from ^male-element-solid-model)) ))
								  )
								  (if (and fem-max male-max)
									  (* ^scale-factor (max fem-max male-max))
									  (if fem-max
										(* ^scale-factor fem-max)
										(* ^scale-factor male-max)
									  )
									)
								)
					available? ^formula
				)
               (max-height :class 'editable-data-property-class
					label "Max height"
					;;Have to check if the max dimensions are not nil to avoid error. Workaround for the open constraint type.
					formula (let (
								   (fem-max (second (the local-max-dimension (:from ^female-element-solid-model))))
								   (male-max (second (the local-max-dimension (:from ^male-element-solid-model)) ))
								  )
								  (if (and fem-max male-max)
									  (* ^scale-factor (max fem-max male-max))
									  (if fem-max
										(* ^scale-factor fem-max)
										(* ^scale-factor male-max)
									  )
									)
							)
                )
			   
               link-ref-incident-on-constraint (list
                                                (the link-ref-incident-on-constraint (:from ^male-element-solid-model))
                                                (the link-ref-incident-on-constraint (:from ^female-element-solid-model))
                                                )
               
			   (load-type :class 'option-property-class
					mode 			'radio
					options-list	(list 'force 'torque)
					formula 		'torque
					label 			"Load type"
					)
			   (magnitude :class 'var-unit-data-property-class
					current-load (case ^^load-type
									('force 'N)
									('torque (progn (add-unit 'Nm 1.0 '(N m)) 'Nm));; Adding the unit should probably only be done once
								  )
					value-in 	1
					unit-in 	^current-load
					unit 		^current-load
					label 		"Magntitude"
					)
			   (load-direction :class 'editable-data-property-class
					formula 	(default ^direction)
					label 		"Load direction vector"
					)
			   
			   ;;not in use from >>>>
			   (constraint-type-selection :class 'option-property-class
					label "Constraint Type"
					mode 'menu
					options-list (class-direct-defined-subclasses 'master-joint-model)
					labels-list (loop for option in !options-list
                                 collect (remove "-constraint-class" (write-to-string option))
                                 )
					formula (progn 
								;(change-value ^constraint-type (remove "-constraint-class" (write-to-string (nth (position ^constraint-type !labels-list) !options-list))))
								(change-class ^male-element-solid-model (read-from-string (concatenate ^constraint-type "-male-element")))
							)
					)
			   
			   meshing-list (list (the display? (:from (the mating-surface-nodes (:from ^male-element-solid-model))))
								  (the display? (:from (the mating-surface-nodes (:from ^female-element-solid-model))))
								  (the display? (:from (the joint-center-node (:from ^male-element-solid-model))))
								  (the display? (:from (the joint-center-node (:from ^female-element-solid-model))))
								  )
			   
			   (toggle-mesh :class 'flag-property-class
					label "Toggle mating-surface-nodes mesh"
					formula (loop for disp in ^meshing-list
								do
									(if (equal disp t) (change-value disp nil) (change-value disp  t))
								)
					;progn (change-value (the display? (:from (the mating-surface-nodes (:from ^male-element-solid-model)))) t)
					;				(change-value (the display? (:from (the mating-surface-nodes (:from ^female-element-solid-model)))) t)
					;				(change-value (the display? (:from (the joint-center-node (:from ^male-element-solid-model)))) t)
					;				(change-value (the display? (:from (the joint-center-node (:from ^female-element-solid-model)))) t)
					;				)
					)
			   ;;Not in use to <<<<
			   
			   ;;Only display properties for non-open constraints
			   property-objects-list (if (is-open-constraint (the superior)) 
				(list "This is an open constraint. No properties can be edited.") 
				(list
					;(the superior toggle-mesh self)
					'("Draw joint" (button1-parameters :draw-joint)
                                        ui-work-area-action-button-class)
					'("Draw male element" (button1-parameters :draw-male)
                                        ui-work-area-action-button-class)
					'("Draw female element" (button1-parameters :draw-female)
                                        ui-work-area-action-button-class)
					""
					'("Undraw" (button1-parameters :undraw)
                                        ui-work-area-action-button-class)
					;(list (the superior constraint-type-selection self) 
					;	'(automatic-apply? t))
					;'("Change joint type" (button1-parameters :change-joint ui-work-area-action-button-class))
					(the superior max-width self)
					(the superior max-height self)
					""
					"Load case"
					(list (the superior load-type self)
						'(automatic-apply? t))
					(list (the superior magnitude self)
						'(automatic-apply? t))
					(list (the superior load-direction self)
						'(automatic-apply? t))
					'("Apply load" (button1-parameters :apply-load)
                                        ui-work-area-action-button-class)
					)
				)
			   )
  :subobjects (
               (male-element-solid-model :class (read-from-string (concatenate !constraint-type "-male-element"))

                   )
               (female-element-solid-model :class (read-from-string (concatenate !constraint-type "-female-element"))
                   (point-ref :class 'point-data-model
                              coordinates (convert-coords ^^superior '(0 0 0) :from :local :to :global)
                              )
							  
                   ;;; convert-coords converts the given vector in the instance's (the local) coordinate frame to a global frame.
				   ;;; Method is defined on ^superior, which is the master-joint-model
				   direction (convert-vector ^superior '(0 0 1) :from :local :to :global)
                   
                   )
               )
  )
 
(define-method get-female-element master-joint-model ()
	(the female-element-solid-model)
)
 
(define-method get-joint-direction-vector master-joint-model () 
	(the male-element-solid-model direction) 
)

(define-method get-main-frame-coords master-joint-model (&optional params)
	(if params
		(nth params !origin)
		!origin
	)
)

(define-method is-open-constraint master-joint-model ()
	(equal "open" !constraint-type)
 )
 
 ;;; Left-click button methods for master-joint-model 
(define-method work-area-button1-action master-joint-model (params)
	(case params
		(:draw-joint
			(draw self)
		)
		(:draw-male
			(draw (the male-element-solid-model))
		)
		(:draw-female
			(draw (the female-element-solid-model))
		)
		(:undraw
			(undraw self)
		)
		(:apply-load
			(let (
					(load-model (if (equal "Yes" (pop-up-message (format nil "Are these settings OK?~%Load type: ~a~%Magnitude: ~a~%Direction: ~a" 
						!load-type !magnitude !load-direction) :width 200 :done-label "Yes" :cancel-label "No"))
						(create-object 'load-model)
						nil))
				  )
				 (if load-model
					(progn
						(change-value (the load-type (:from load-model)) !load-type)
						(change-value (the magnitude (:from load-model)) !magnitude)
						(change-value (the load-direction (:from load-model)) !load-direction)
						(change-value (the loadID (:from load-model)) (1+ (get-male-triad-id-from-master-joint-model (the))))
						(add-load (the superior superior) load-model)
					)
				 )
			)
		)
	)
)
 
(define-class sub-point-model
  :inherit-from (point-data-model)
  :properties (
               reference-object ^main-frame
               coordinates '(0 0 0)
               )
  )
(define-class sub-frame-model
  :inherit-from (frame-data-model)
  :properties (
               ;;When a sub-point-ref is specified in a joint element, its sub-frame will be placed accordingly
			   (point-ref :class 'point-data-model
                   coordinates (convert-coords ^sub-point-ref (the coordinates (:from ^sub-point-ref)))
                   )
               )
  )

;;; Superclass for male and female joint elements
(define-class joint-element-model
  :inherit-from (general-joint-solid-model)
  :properties (
			   ;;; union-list is the list used for a union with the incident link. 
			   ;;; different-list is the list of objects that are to be subtracted from the final geometry.
			   ;;; See link-geometry-class in links.aml for the use
               union-list nil
               difference-list nil
               
			   max-element-size (when (and ^max-width ^max-height)
									(/ (min ^max-width ^max-height) 4)
									)
			   min-element-size (when (and ^max-width ^max-height)
									(/ (min ^max-width ^max-height) 8)
									)
			   
               display? t
               gender (read-from-string (remove "-element-solid-model" (write-to-string (object-name !superior)))) 
               gender_int (case ^gender ('male 0) ('female 1) )
               link-incidence (nth ^gender_int ^^link-incidence)
			   
               link-ref-incident-on-constraint (get-link-ref ^links ^link-incidence)
			   link-mesh-model-object (when (the link-mesh-model (:from ^link-ref-incident-on-constraint))
										(the link-mesh-model (:from ^link-ref-incident-on-constraint)))
               
               local-joint-index (position !superior (the constraints-incident-on-link-list (:from ^link-ref-incident-on-constraint)) )
               members-connected-to-joint-element (loop for member in (the members-ref-list (:from (the link-solid-geometry (:from ^link-ref-incident-on-constraint)) ))
                                                    when (position !superior (the connection-between-constraints (:from member)))
                                                    collect member
                                                    )
               
			   local-max-dimension (loop for member in (the members-ref-list (:from (the link-solid-geometry (:from ^link-ref-incident-on-constraint))))
                                     for pos = (position !superior (the connection-between-constraints (:from member)))
                                     when (and pos (the display? (:from member)))
                                     maximize (if (= pos 0)
                                                  (max-width (the cross-section_D (:from member)) )
                                                (max-width (the cross-section_A (:from member)) ) ) into max-w
                                     and  maximize (if (= pos 0)
                                                       (max-height (the cross-section_D (:from member)) )
                                                     (max-height (the cross-section_A (:from member)) ) ) into max-h
                                     finally (return (list max-w max-h))
                                     )

               (sub-point-ref :class 'sub-point-model
                   )
			   
			   ;;Property used for writing to FEDEM
			   is-incident-link-drawable? 	(the is-link-drawable? (:from ^link-ref-incident-on-constraint))
               )
  :subobjects (
                (main-frame :class 'frame-data-model
					;;; inherited frame properties used in main-frame and sub-frame
					(x-vector-ref :class 'vector-data-model
						direction (let (
										(first-sweep (nth 0 ^members-connected-to-joint-element))
										(x-dir  (subtract-vectors
												(the coordinates (:from (the point-ref (:from (nth 0 (the connection-between-constraints (:from first-sweep) ) )))))
												(the coordinates (:from (the point-ref (:from (nth 1 (the connection-between-constraints (:from first-sweep) ) ))))))
											)
										(x-dir-normal (cross-product ^^direction (cross-product ^^direction x-dir)))
									   )
									   (if (equal 0 (vector-length x-dir-normal))
											x-dir-normal
											(arbitrary-normal-to-vector ^^direction)
										)
									)
                    )
                )
				;;; An element's sub-frame is placed by specifying the sub-point-ref in the element's properties
               (sub-frame :class 'sub-frame-model
                   )
			   (joint-center-node :class 'mesh-node-class
                   coordinates (the origin (:from ^main-frame))
                   mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
				   display? nil
                   )
               )
  )

(define-method get-max-height joint-element-model ()
	(when !max-height !max-height)
)
 
(define-method is-open-constraint joint-element-model ()
	(equal "open" !constraint-type)
 ) 
 
(define-method get-main-frame-coords joint-element-model (&optional params)
	(if params
		(nth params (the main-frame origin))
		(the main-frame origin)
	)
)
;; Used in (write-fmm-model-file) to generate unique IDs for each joint element  
(define-method get-joint-element-id joint-element-model ()
	(1- (+ (* 2 !id) !gender_int)) ;; This value will be valid as long as there are two parts of a joint
)

;; Used in (write-fmm-model-file) to connect master/slave triads to the joint elements
(define-method get-male-triad-id-from-master-joint-model master-joint-model ()
	(1- (* 2 !id))
)
  
(define-method get-constraint-incidence master-joint-model (link-index)
  (let (
        (pos (position link-index !link-incidence) )
        )
    (when pos
      (nth pos (children (the) :class 'general-joint-solid-model))
      )
    )
  )

(define-method get-constraint-incidence joint-element-model (link-index)
 (when (member link-index ^link-incidence) (the self))
 )

;;; An open constraint is a joint with no geometry
;;; Used for leaving the end of a link open 
(define-class open-constraint-class
  :inherit-from (master-joint-model)
  :properties (
               )
  )
(define-class open-male-element
  :inherit-from (joint-element-model)
  :properties (
               )
  )
(define-class open-female-element
  :inherit-from (joint-element-model)
  :properties (
			   ;; An open female joint could initially be placed at the wrong place, 
			   ;; depending on the topology of the mechanism. Its sub-frame should
			   ;; then be placed accordingly. The local z coordinate is translated,
			   ;; as that's the direction from the main-frame to the sub-frame.
               z-translation (get-translational-z-value (the superior))
			   (sub-point-ref :class 'sub-point-model
                   orientation (list
								(translate (list 0 0 ^z-translation))
                                )
                   )
               )
  )
  
;;Method finding the other joint on member, and then retrieving its max height.
(define-method get-translational-z-value open-female-element ()
	(let (
		  (displayed-member
			(loop for member in !members-connected-to-joint-element
				when (the display? (:from member)) do
				(return member)))
		  )
		 (loop for joint in (get-joints-on-member displayed-member)
			when (not (eq (the) joint)) do
			(return (-(get-max-height joint)))
		  )
	)
)
  
(define-class rigid-constraint-class
  :inherit-from (master-joint-model)
  :properties (
               )
  )


(define-class helical-constraint-class
  :inherit-from (master-joint-model)
  :properties (
;;;                joint-variables 'theta or 's
               ;;;                to element
;;;                (temp-element :class 'vector-data-model
;;;                    point-ref  ^^point-ref
;;;                    direction  ^^direction
                   orientation (list
                                  (translate !direction :distance (nth 0 !constraint-variable)) 
                                  )
;;;                    )
               )
  
  )




(define-class prismatic-constraint-class
  :inherit-from (master-joint-model)
  :properties (
;;;                joint-variables 's
               ;;;                to element
;;;                (temp-element :class 'vector-data-model
;;;                    point-ref  ^^point-ref
;;;                    direction  ^^direction
                   orientation (list
                                  (translate !direction :distance (nth 0 !constraint-variable)) 
                                  )
;;;                    )
               )
  )

(define-class cylindric-constraint-class
  :inherit-from (master-joint-model)
  :properties (
;;;                joint-variables 'theta and 's
               ;;;                to element
;;;                (temp-element :class 'vector-data-model
;;;                    point-ref  ^^point-ref
;;;                    direction  ^^direction
                   orientation (list
					   (translate !direction :distance (nth 0 !constraint-variable)) 
                                  )
;;;                    )
               )
  )

(define-class planar-constraint-class
  :inherit-from (master-joint-model)
  :properties (
;;;                joint-variables 's, s' and  theta
 
;;;                (temp-element :class 'vector-data-model
;;;                    orientation (list
;;;                                 (translate
;;;                                  (angle-between-2-vectors (the superior solid-element direction) (nth 0 ^^constraint-variable) )
;;;                                  (cross-product (the superior solid-element direction)  (nth 0 ^^constraint-variable) )
;;;                                  :axis-point (the coordinates (:from (the superior solid-element point-ref)) )
;;;                                  )
;;;                                 )
;;;                    )
               )
  )

;;; Class holding revolute male and female elements on instantiation
(define-class revolute-constraint-class
  :inherit-from (master-joint-model)
  :properties (
               diameter 0
               ;;; dimensions to make sure connected joints match
               )
  )


(define-class revolute-male-element
  :inherit-from (joint-element-model)
  :properties (
               union-list (when (and (plusp ^max-width) (plusp ^max-height) )
                            (list ^imprinted-pin ^eye)
                            )
               
			   object-list (list ^imprinted-pin ^eye)
               
			   simplify? nil

			   mating-nodes-distance (/ ^^max-width 2)
			   
			   ;;; Imprinted objects are objects that will receive surface nodes, used for meshing
               (imprinted-pin :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^pin
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
               
               (pin :class 'cylinder-object
                   reference-object ^main-frame
                   height (* 2 ^^max-height ^^scale-factor)
                   diameter (/ ^^max-width 2)
                   orientation (list
                                (translate (list 0 0 (- (/ ^height 4)) ) )
                                )
                   )
               (eye :class '(tagging-object cylinder-object)
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   reference-object ^sub-frame
                   height ^^max-height
                   diameter ^^max-width
                   )
               (sub-point-ref :class 'sub-point-model
                   orientation (list
                                (translate (list 0 0 (/ (- ^^max-height) 1) ))
                                )
                   )
               )
  :subobjects (
               (mating-surface-nodes :class 'mesh-query-nodes-from-interface-class
					mesh-database-object			(get-mesh-model-subobject ^^link-mesh-model-object 'mesh-db)
					interface-object 				(the point-ref (:from ^^main-frame))
					tolerance 						(sqrt (+ (expt (/ (the height (:from ^^pin)) 4) 2) (expt (/ (the diameter (:from ^^pin)) 2) 2)))
					quantity 						nil ;;Collect all nodes within the tolerance
					subset-mesh-query-object-list	(list (get-mesh-model-subobject ^^link-mesh-model-object '2d-elements))
					color 							'green
					display							nil
					)
               )
  )
	
(define-class revolute-female-element
  :inherit-from (difference-object joint-element-model)
  :properties(
               union-list (when (and (plusp ^max-width) (plusp ^max-height) )
							(list ^fork)
                           )
               difference-list (when (and (plusp ^max-width) (plusp ^max-height) )
                                (list ^imprinted-pin-hole)
                                )
               object-list (list ^fork ^imprinted-pin-hole)
			   
			   (imprinted-pin-hole :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^pin-hole
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
               
               (pin-hole :class 'cylinder-object
                   reference-object ^main-frame
                   height (* 4 ^^max-height ^^scale-factor)
                   diameter (/ ^^max-width 2)
                   )
                              
               (fork :class '(tagging-object cylinder-object)
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   reference-object ^sub-frame
                   height ^^max-height
                   diameter ^^max-width
                   )

               (sub-point-ref :class 'sub-point-model
                   )
               )
  :subobjects (
              
               (mating-surface-nodes :class 'mesh-nodes-query-class
                   tagged-object-list (list ^^imprinted-pin-hole)
				   mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
                   color 'green
				   display? nil
                   )
               )
  )

;;; Class holding spherical male and female elements on instantiation
(define-class spheric-constraint-class
  :inherit-from (master-joint-model)
  :properties (
			   orientation (list
							(rotate
							 (angle-between-2-vectors ^direction (nth 0 ^constraint-variable) )
							 (cross-product ^direction (nth 0 ^constraint-variable) )
							 :axis-point (the coordinates (:from ^point-ref) )
							 )
							)
               )
  )

(define-class spheric-male-element
  :inherit-from (union-object joint-element-model)
  :properties (
               tag-dimensions '(1 2 3)
               tag-attributes (list ^^max-element-size ^^min-element-size
                                    0 0.1 0 20.0 1.0e-5)
               union-list (when (and (plusp ^max-width) (plusp ^max-height) )
                            (list ^imprinted-stud ^imprinted-ball ^plate)
                            )
			   object-list (list ^imprinted-stud ^imprinted-ball ^plate)

               (imprinted-stud :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^stud
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
               (stud :class 'cylinder-object
                   reference-object ^sub-frame
                   height (vector-length (subtract-vectors (the origin (:from ^sub-frame)) (the origin (:from ^main-frame)) ) )
                   diameter (/ (the diameter (:from ^ball)) 2)
                   orientation (list
                                (translate (list 0 0 (/ ^height 2)) )
                                )
                   )
               (imprinted-ball :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^ball
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
               (ball :class 'sphere-object
                   reference-object ^main-frame
                   diameter (* 3 (/ ^^max-width 4))
                   )
               (plate :class '(tagging-object cylinder-object)
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   reference-object ^^sub-frame
                   diameter ^^max-width
                   height ^^max-height
                   )

               (sub-point-ref :class 'sub-point-model
                   orientation (list
                                (translate (list 0 0  (- 0 (/ ^^max-height 2) (* 1 (the diameter (:from ^^ball))) )) )
                                )
                   )
               )
  :subobjects (
               (mating-surface-nodes :class 'mesh-nodes-query-class
                   tagged-object-list (list ^^imprinted-ball)
                   mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
                   color 'green
				   display? nil
                   )               
               )
  )

(define-class spheric-female-element
  :inherit-from (difference-object joint-element-model)
  :properties (
               union-list (when (and (plusp ^max-width) (plusp ^max-height) )
                            (list ^imprinted-socket)
                            )
               difference-list (when (and (plusp ^max-width) (plusp ^max-height) )
                                 (list ^imprinted-hole)
                                 )
               object-list (list ^imprinted-socket ^imprinted-hole)

               (imprinted-hole :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^hole
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
               (hole :class 'sphere-object
                   reference-object ^sub-frame
                   diameter (* 3 (/ ^^max-width 4))
                   )
               (imprinted-socket :class '(tagging-object geometry-with-split-periodic-faces-class)
                   source-object ^^socket
                   tag-dimensions '(1 2 3)
                   tag-attributes (list ^^max-element-size ^^min-element-size
                                        0 0.1 0 20.0 1.0e-5)
                   )
                             
               (socket :class 'intersection-object
                   object-list (list ^sphere ^cyl)
                   reference-object ^sub-frame
                   )

               (sphere :class 'sphere-object
                   diameter ^^max-width
                   )

               (cyl :class 'cylinder-object
                   height ^^max-height
                   diameter ^^max-width             
                   )
               )
  :subobjects (
               (mating-surface-nodes :class 'mesh-nodes-query-class
                   tagged-object-list (list ^^imprinted-hole)
                   mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
                   color 'green
				   display? nil
                   )
               )
  )
  
;;; Class holding knuckle male and female elements on instantiation
(define-class solid-knuckle-constraint-class  
	:inherit-from (master-joint-model)
	:properties (
				 )
 )
 
(define-class solid-knuckle-female-element
	:inherit-from (difference-object joint-element-model)
	:properties (	
				  outer-radius (* ^max-width ^scale-factor)
				  inner-radius (* ^outer-radius 0.6)
				
				  union-list (when (and (plusp ^max-width) (plusp ^max-height) )
					   (list !superior)
					   )
				  difference-list (when (and (plusp ^max-width) (plusp ^max-height) )
									(list ^imprinted-pin-hole)
									)
				  object-list (list ^eye ^imprinted-pin-hole)

				  (imprinted-pin-hole :class '(tagging-object geometry-with-split-periodic-faces-class)
					   source-object ^^pin-hole
					   tag-dimensions '(1 2 3)
					   tag-attributes (list ^^max-element-size ^^min-element-size
											0 0.1 0 20.0 1.0e-5)
					   )
				   
				  (pin-hole :class 'cylinder-object
					   reference-object ^main-frame
					   height (* ^^inner-radius 4)
					   diameter ^^inner-radius
					   )
								  
				  (eye :class '(tagging-object cylinder-object)
					   tag-dimensions '(1 2 3)
					   tag-attributes (list ^^max-element-size ^^min-element-size
											0 0.1 0 20.0 1.0e-5)
					   reference-object ^sub-frame
					   height ^^max-height
					   diameter ^^outer-radius
					   )

				  (sub-point-ref :class 'sub-point-model
					   )

		   
				 )
	:subobjects (
					(mating-surface-nodes :class 'mesh-nodes-query-class
						   tagged-object-list (list ^^imprinted-pin-hole)
						   mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
						   color 'green
						   display? nil
						)
				)
 )

(define-class solid-knuckle-male-element
  :inherit-from (union-object joint-element-model)
  :properties (
			   ;;; Helping variables
			   outer-radius (* ^max-width ^scale-factor)
			   inner-radius (* ^outer-radius 0.6)
			   
			   ;;; Lists sent to link-geometry-class ------->
               union-list (when (and (plusp ^max-width) (plusp ^max-height) )
                            (list !superior) ;!superior is a reference to the union object?
                            )
               difference-list (when (and (plusp ^max-width) (plusp ^max-height) )
                                (list ^subtracted-box)
                                )
			   ;;; <-------
			   
			   object-list (list ^pin ^fork)
               simplify? t
			   
			   (imprinted-pin :class '(tagging-object geometry-with-split-periodic-faces-class)
				   source-object ^^pin
					   tag-dimensions '(1 2 3)
					   tag-attributes (list ^^max-element-size ^^min-element-size
											0 0.1 0 20.0 1.0e-5)
					)
			   
			   ;;; Objects used to create the male joint geometry ---->
			   (fork :class 'difference-object
					object-list (list ^^box ^^subtracted-box ^^trim-object ^^sphere)
					)
				
			   (subtracted-box :class 'box-object
					reference-object ^main-frame
					width (* ^^outer-radius 1.5)
					height ^^outer-radius
					depth ^^max-width
					orientation (list
                                (translate (list (- (* 0.75 ^^outer-radius) ^^inner-radius) 0 0 ))
                                )
					)
			   
			   (box :class 'box-object
					reference-object ^main-frame
					width (* ^^outer-radius 2)
					height ^^outer-radius
					depth (* ^^outer-radius 1.5)
					orientation (list
                                (translate (list (- ^^outer-radius ^^inner-radius) 0 0 ))
                                )
					)
                   
               (pin :class 'cylinder-object
                   reference-object ^main-frame
                   diameter ^^inner-radius
                   height (* ^^outer-radius 2)
                   )
				
			   (trim-box :class 'box-object
					reference-object ^main-frame
					width ^^inner-radius
					height ^^outer-radius
					depth (* ^^outer-radius 1.5)
					orientation (list 
								(translate (list (* ^^inner-radius -0.5) 0 0))
								)
					)
				
			   (trim-cyl :class 'cylinder-object
					reference-object ^main-frame
					diameter ^^outer-radius
					height (* ^^outer-radius 1.5)
					)
				
			    (trim-object :class 'difference-object
					object-list (list ^^trim-box ^^trim-cyl)
					)
			    
				
				(difference-sphere :class 'sphere-object
					reference-object ^main-frame
					diameter (* ^^outer-radius 3)
					)
					
				(trim-sphere :class 'sphere-object
					reference-object ^main-frame
					diameter (* ^^outer-radius 4)
					)
					
				(sphere :class 'difference-object
					object-list (list ^^trim-sphere ^^difference-sphere)
					)
				;;; <-------
				
				;;; Used as the difference-list in link-geometry-class --->
               (difference-box :class 'difference-object
					object-list(list ^^subtracted-box ^^eye)
					)
			   (eye :class '(cylinder-object)
					   reference-object ^main-frame
					   height ^^max-height
					   diameter ^^outer-radius
					   )
			   ;;; <-----	 
				
			   ;;; Defines where the sub-frame should be placed
			   (sub-point-ref :class 'sub-point-model
					orientation
							(list (translate (list (- (* ^^outer-radius 2) ^^inner-radius) 0 0)))
							
					)
				)
  :subobjects (
					(mating-surface-nodes :class 'mesh-nodes-query-class
						tagged-object-list (list ^^imprinted-pin)
						mesh-object (the link-mesh (:from (the link-mesh-model (:from ^link-ref-incident-on-constraint))))
						color 'green
						display? nil
					)
               )
  )
;;; -----------------------------
;;; END CONSTRAINT DEFINITIONS
;;; -----------------------------
